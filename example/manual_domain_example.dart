// ignore_for_file: unused_element

/// This example demonstrates the new dart_tree architecture with:
/// - Extension-based code generation
/// - Automatic JSON/YAML serialization
/// - Formatting metadata preservation
///
/// USER WRITES:
/// - Domain objects extending TreeObject
/// - Annotations (@treeObject, @TreeChild)
/// - Non-abstract Tree class marked with @GenerateTree
///
/// GENERATOR CREATES:
/// - TreeNode classes for each domain object
/// - Extension on user's Tree class with objectToNode implementation
/// - Serialization extensions (toJson, fromJson, toYaml, fromYaml)
library;

import 'package:dart_tree/dart_tree.dart';

// NOTE: In real usage, this would be:
// part 'manual_domain_example.g.dart';
// For this example, we simulate it with a manual file
part 'manual_domain_example_manual.dart';

// =============================================================================
// USER CODE - What the user writes
// =============================================================================

/// User defines their domain objects using TreeObject types (not primitives!)
@treeObject
class BlogPost extends TreeObject {
  final StringValue title;
  final StringValue? author;

  @TreeChild()
  final Content content;

  @TreeChild()
  final CommentsList comments;

  const BlogPost({required this.title, this.author, required this.content, required this.comments});

  // These would be generated by dart_tree_gen
  @override
  String toJson() => _$BlogPostToJson(this);

  @override
  String toYaml() => _$BlogPostToYaml(this);

  static BlogPost fromJson(dynamic json) => _$BlogPostFromJson(json);

  static BlogPost fromYaml(dynamic yaml) => _$BlogPostFromYaml(yaml);
}

@treeObject
class Content extends TreeObject {
  final StringValue body;
  final IntValue? wordCount;

  const Content({required this.body, this.wordCount});

  // These would be generated by dart_tree_gen
  @override
  String toJson() => _$ContentToJson(this);

  @override
  String toYaml() => _$ContentToYaml(this);

  static Content fromJson(dynamic json) => _$ContentFromJson(json);

  static Content fromYaml(dynamic yaml) => _$ContentFromYaml(yaml);
}

@treeObject
class Comment extends TreeObject {
  final StringValue author;
  final StringValue text;
  final BoolValue approved;

  const Comment({required this.author, required this.text, required this.approved});

  // These would be generated by dart_tree_gen
  @override
  String toJson() => _$CommentToJson(this);

  @override
  String toYaml() => _$CommentToYaml(this);

  static Comment fromJson(dynamic json) => _$CommentFromJson(json);

  static Comment fromYaml(dynamic yaml) => _$CommentFromYaml(yaml);
}

/// List of comments (user-defined collection)
@treeObject
class CommentsList extends ListObject<Comment> {
  CommentsList(super.elements, {super.jsonArrayStyle, super.yamlSequenceStyle});

  static CommentsList fromJson(dynamic json) => _$CommentsListFromJson(json);

  static CommentsList fromYaml(dynamic yaml) => _$CommentsListFromYaml(yaml);
}

/// User's Tree class - non-abstract!
/// The generator will create an extension with objectToNode
@GenerateTree()
class BlogTree extends Tree {
  BlogTree({required super.root});
}

// =============================================================================
// USAGE - How the user would use it
// =============================================================================

void main() {
  print('=== Creating Blog Post ===\n');

  // Create domain objects with optional formatting metadata
  final post = BlogPost(
    title: const StringValue('My First Post', jsonStringStyle: JsonStringStyle(doubleQuoted: true)),
    author: const StringValue('Alice'),
    content: const Content(body: StringValue('This is the content...'), wordCount: IntValue(42)),
    comments: CommentsList(const [
      Comment(author: StringValue('Bob'), text: StringValue('Great post!'), approved: BoolValue(true)),
      Comment(author: StringValue('Charlie'), text: StringValue('Thanks for sharing'), approved: BoolValue(false)),
    ]),
  );

  print('=== Creating Tree ===\n');
  // Convert to tree - objectToNode is provided by generated extension
  final tree = BlogTree(root: post);
  print('Tree created with root: ${tree.root?.runtimeType}\n');

  print('=== Navigating Tree Nodes ===\n');
  // Navigate using generated nodes
  final postNode = tree.root as BlogPostNode;
  print('Title: ${postNode.title.value}');
  print('Author: ${postNode.author?.value}');
  print('Body: ${postNode.content.body.value}');
  print('Word Count: ${postNode.content.wordCount?.value}');
  print('Comments: ${postNode.comments.length}\n');

  print('=== Tree Traversal ===\n');
  // Tree operations
  tree.traverse((node, depth, path) {
    final indent = '  ' * depth;
    print('$indent${node.runtimeType} @ $path');
  });

  print('\n=== Querying by Path ===\n');
  // Query by path
  final firstCommentAuthor = tree.getString('/comments/0/author');
  print('First comment by: $firstCommentAuthor');

  final isApproved = tree.getBool('/comments/0/approved');
  print('Is approved: $isApproved\n');

  print('=== JSON Serialization (Object Methods) ===\n');
  // All TreeObjects have toJson() methods that recursively encode
  // Value objects (StringValue, IntValue, etc.) implement their own encoding
  // Collection objects (ListObject, MapObject) recursively call toJson() on elements
  // Custom objects use generated toJson() that iterates over properties
  print('All TreeObjects have toJson() methods for encoding:');
  print('  - ValueObjects: Encode primitives with formatting metadata');
  print('  - Collections: Recursively call toJson() on elements');
  print('  - Custom objects: Use generated toJson() with toEncodableMap()\n');
  print('Example: post.toJson() produces JSON string with all metadata applied');
  print('Each nested field calls its own toJson() method recursively.\n');

  print('=== YAML Serialization (Object Methods) ===\n');
  // Same pattern for YAML - each object knows how to encode itself
  print('All TreeObjects have toYaml() methods for encoding:');
  print('  - ValueObjects: Encode with YAML-specific formatting (quotes, scalars)');
  print('  - Collections: Block or flow style based on metadata');
  print('  - Custom objects: Use generated toYaml() with toEncodableMap()\n');
  print('Example: post.toYaml() produces YAML string with all metadata applied\n');

  print('=== Formatting Metadata Example ===\n');
  // Demonstrate formatting metadata
  final styledString = StringValue(
    'Hello, World!',
    jsonStringStyle: const JsonStringStyle(doubleQuoted: true, originalRepresentation: '"Hello, World!"'),
    yamlStringStyle: const YamlStringStyle(
      quoteStyle: YamlStringQuoteStyle.single,
      originalRepresentation: "'Hello, World!'",
    ),
  );
  print('String value: ${styledString.value}');
  print('JSON style: double-quoted = ${styledString.jsonStringStyle?.doubleQuoted}');
  print('YAML style: quote style = ${styledString.yamlStringStyle?.quoteStyle}');
}
